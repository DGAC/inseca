#!/usr/bin/python3

# This file is part of INSECA.
#
#    Copyright (C) 2020-2022 INSECA authors
#
#    INSECA is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    INSECA is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with INSECA.  If not, see <https://www.gnu.org/licenses/>

#
# This file starts the system, monitors it and offers a DBus service to change the password or trigger an update
#
# This script is run as root.
#

import sys
import os
import gi
import json
import syslog
import datetime
import time
import Utils as util
import Jobs as jobs
import Device
import CryptoGen as crypto
import Live
import Misc
import Sync

# sanity checks
if not util.is_run_as_root():
    raise Exception("This script needs to be run as root")

syslog.syslog(syslog.LOG_INFO, "Program started")
live_env=Live.Environ()
while not live_env.define_UI_environment():
    syslog.syslog(syslog.LOG_INFO, "User not yet created...")
    time.sleep(2)

# proxy setup
proxy_pac_file="/opt/share/proxy.pac"
if os.path.exists(proxy_pac_file):
    Sync.proxy_pac_file=proxy_pac_file

# UI
gi.require_version("Gtk", "3.0")
from gi.repository import Gtk
from gi.repository import GLib

import dbus
import dbus.service
import dbus.mainloop.glib

# Misc.
updates_enabled=True

#
# UI
#
class UI:
    """Contains all the UI features"""
    def __init__(self, live_env):
        if not isinstance(live_env, Live.Environ):
            raise Exception("Code bug")
        self._live_env=live_env

        self.scriptdir=os.path.realpath(os.path.dirname(sys.argv[0]))
        self._builder=Gtk.Builder()
        self._builder.add_from_file("%s/%s"%(self.scriptdir, "main.ui"))
        self._main_window=self._builder.get_object("main")
        self._main_window.set_icon_from_file("/opt/inseca-manager/logo-128.png")
        self._main_nb=self._builder.get_object("main-nb")
        self._builder.connect_signals(self)

        self._tried_password_times=0

        # version and informations
        self._version=None
        self._valid_from=None
        self._valid_to_ts=None
        self._valid_to_str=None
        self._add_ui_key_infos()

        # Misc.
        live_env.user_setting_set("org.gnome.software", "allow-updates", "false")

        # check if expired
        self.expired=False
        if self._valid_to_ts:
            now=datetime.datetime.utcnow()
            ts=int(now.timestamp())
            if ts<self._valid_from or ts>self._valid_to_ts:
                self.expired=True
        else:
            self.expired=True

        self.remote=None

    @property
    def live_env(self):
        return self._live_env

    @property
    def version(self):
        return self._version

    @property
    def valid_to(self):
        return self._valid_to_str

    def _add_ui_key_infos(self):
        """Load system's information from when the live build was generated and display it in the UI"""
        try:
            label=self._builder.get_object("infos-label")
            keyinfos=json.loads(util.load_file_contents("/opt/share/keyinfos.json"))
            self._version=keyinfos["version"]
            self._valid_from=keyinfos["valid-from"]
            self._valid_to_ts=keyinfos["valid-to"]
            valid_to_dt=datetime.datetime.fromtimestamp(self._valid_to_ts - 1)
            self._valid_to_str=valid_to_dt.strftime('%d/%m/%Y')
            text="<small>Version %s (valide jusqu'au %s)</small>"%(self._version, self._valid_to_str)
            label.set_markup(text)
        except Exception as e:
            syslog.syslog(syslog.LOG_INFO, "Infos error: %s"%str(e))

    def icon_pressed(self, entry, icon_position, event):
        entry.set_visibility(True)

    def icon_released(self, entry, icon_position, event):
        entry.set_visibility(False)

    def on_password_button_clicked(self, button):
        """Callback after user enterered password"""
        (enc_data, enc_int)=(None, None)
        try:
            Misc.stop_killer_counter()
            already_done=os.path.exists("/internal/resources") # in case user previously closed session
            if not already_done:
                # unlock and mount encrypted volumes
                self._tried_password_times+=1
                widget=self._builder.get_object("password")
                passwd=widget.get_text()
                self.show_message("Unlocking device...")
                job=jobs.InsecaStartupJob(self._live_env, passwd)
                job.start()
                job.wait_with_ui()
                if job.exception:
                    errmsg=str(job.exception)
                    self._live_env.notify("Error: %s"%errmsg)
                    if self._tried_password_times>=3:
                        errmsg="Le nombre maximal de tentatives\nde mot de passe a été atteint"
                        self.show_error(errmsg)
                    else:
                        self.show_page("password")
                    return
                (blob0, int_password, data_password)=job.result

                # enable networking
                Misc.enable_networking()

                # change the user's wallpaper to mark the end of the boot process
                if os.path.exists("/internal/resources/default-wallpaper"):
                    self._live_env.user_setting_set("org.gnome.desktop.background", "picture-uri",
                                                    "/internal/resources/default-wallpaper")
                    self._live_env.user_setting_set("org.gnome.desktop.background", "picture-options", "stretched")

                # finish setup of files
                self.show_message("Final setup...")
                job=jobs.InsecaPostStartupJob(self._live_env, passwd)
                job.start()
                job.wait_with_ui()
                if job.exception:
                    raise job.exception

                # configure components, stage 0 (BEFORE the user config is applied)
                self.show_message("Components initialization...")
                job=jobs.InsecaConfigureComponentsJob(self._live_env, 0)
                job.start()
                job.wait_with_ui()
                if job.exception:
                    raise job.exception

                # extraction of default user profile and user config files (saved upon previous session close)
                self.show_message("Extraction des fichiers de configuration")
                job=jobs.ConfigFilesExtractJob(self._live_env)
                job.start()
                job.wait_with_ui()
                if job.exception:
                    raise job.exception

                # configure components, stage 1 (AFTER the user config is applied)
                self.show_message("Components initialization...")
                job=jobs.InsecaConfigureComponentsJob(self._live_env, 1)
                job.start()
                job.wait_with_ui()
                if job.exception:
                    raise job.exception

                # remove any NO-BACKUP mark
                self._live_env.user_config_clean_nobackup()

            # request to apply staged updates and get updates
            if self.remote:
                self.remote.apply_staged(blob0, int_password, data_password)
                if updates_enabled:
                    GLib.timeout_add(1000, get_updates_startup, self.remote)

            # final notice
            self.show_page("final", can_close=True)

        except Exception as e:
            if enc_data:
                enc_data.umount()
            if enc_int:
                enc_int.umount()
            self.show_error(str(e))

    def on_close_button_clicked(self, button):
        self.hide()

    #
    # Generic UI
    #
    def show_message(self, message, can_close=False):
        self.show_page("message", can_close)
        if message:
            widget=self._builder.get_object("message")
            widget.set_markup("<span size='large'>"+message+"</span>")

    def show_warning(self, message):
        self.show_page("warning", True)
        if message:
            widget=self._builder.get_object("warnmsg")
            widget.set_markup("<span size='large'>"+message+"</span>")

    def show_error(self, message, kill_after_delay=True):
        self.show_page("error", not kill_after_delay)
        widget=self._builder.get_object("errormsg")
        widget.set_markup("<span size='large'>"+message+"</span>")

        if kill_after_delay:
            Misc.start_killer_counter()
        else:
            close_button=self._builder.get_object("close-button")
            close_button.show()

    def show_page(self, page, can_close=False):
        indexes={
            "message": 0,
            "error": 1,
            "password": 2,
            "final": 3,
            "warning": 4
        }
        self._main_nb.set_current_page(indexes[page])
        self._main_window.present()
        self._main_window.set_keep_above(True)

        close_button=self._builder.get_object("close-button")
        password_button=self._builder.get_object("password-go-button")
        # buttons and more
        if page=="password":
            Misc.start_killer_counter(60)
            can_close=False
            password_button.show()
            close_button.hide()
        else:
            password_button.hide()
            close_button.set_sensitive(can_close)
            close_button.show()

    def hide(self):
        self._main_window.hide()

#
# Remote control using DBus
#
class Remote(dbus.service.Object):
    def __init__(self, conn, ui, object_path="/remote"):
        dbus.service.Object.__init__(self, conn, object_path)
        self._ui=ui

        self._device_config_file="/internal/resources/config.json"

        # update management
        self._stage_dir="/internal/update-staging"
        self._get_updates_job=None
        self._apply_update_job=None

    #
    # User management API
    #
    @dbus.service.method("inseca.Manager.UserEnv")
    def change_password(self, current_password, new_password):
        """Change the user's password"""
        # check new password
        crypto.validate_password(new_password)

        # check password is really changed
        if current_password==new_password:
            raise Exception("Mots de passe identiques")

        job=jobs.PasswordChangeJob(self._ui.live_env, current_password, new_password)
        job.start()
        job.wait_with_ui()
        if job.exception:
            raise job.exception

        # change the current session's password
        (status, out, err)=util.exec_sync(["chpasswd"], stdin_data="insecauser:%s"%new_password)
        if status!=0:
            raise Exception("Could not change logged user's password: %s"%err)

    @dbus.service.method("inseca.Manager.UserEnv")
    def delete_user_config(self):
        """Delete the data associated with the current user, and avoid saving these data when the session
        terminates"""
        self._ui.live_env.user_config_remove()

    #
    # Status info
    #
    @dbus.service.method("inseca.Manager.Status")
    def get_updates_status(self):
        """Get what the system is doing regarding updates.
        Returns '' (empty string) if the system is idle."""
        status=[]
        if self._get_updates_job is not None:
            status+=["Getting updates"]
        if self._apply_update_job is not None:
            status+=["Applying already downloaded update"]
        return ", ".join(status)

    @dbus.service.signal("inseca.Manager.Status", signature="")
    def status_changed(self):
        syslog.syslog(syslog.LOG_INFO, "Status changed!")

    @dbus.service.method("inseca.Manager.Status")
    def get_version(self):
        return self._ui.version

    @dbus.service.method("inseca.Manager.Status")
    def get_valid_to(self):
        return self._ui.valid_to

    @dbus.service.method("inseca.Manager.Status", out_signature="a{ss}")
    def get_extra_infos(self):
        # execute the infos.py script for all the components which have one script
        infos={} # key=component name, value=component status
        exec_env=os.environ.copy()
        exec_env["PYTHONPATH"]=os.path.dirname(__file__)
        comp_live_config_dir=self._ui.live_env.components_live_config_dir
        components=os.listdir(comp_live_config_dir)
        for component in components:
            script="%s/%s/infos.py"%(comp_live_config_dir, component)
            if os.path.exists(script):
                exec_env["USERDATA_DIR"]="/internal/components/%s"%component
                (status, out, err)=util.exec_sync([script], exec_env=exec_env)
                lines=out.splitlines()
                if len(lines)>0:
                    cid=lines[0]
                    if status==0:
                        infos[cid]="\n".join(lines[1:])
                    elif status==255:
                        # component not available (e.g. some userdata is missing)
                        pass
                    else:
                        # infos.py script failed
                        infos[cid]=err
                else:
                    syslog.syslog(syslog.LOG_ERR, "Invalid output from the infos.py script of component '%s'"%component)
        return infos

    #
    # Updates API
    #
    @dbus.service.signal("inseca.Manager.GetUpdates", signature="is")
    def finished_get_updates(self, status, message):
        """Signal that the job of getting updates is finished
        status:
        -1: an error occurred
         0 => no update available
         1 => an update has been staged
         2 => a stage update is being applied
        """
        syslog.syslog(syslog.LOG_INFO, "Get updates finished: %s, %s"%(status, message))

    def _check_get_updated_job_finished(self, job):
        #print("Checking to see if get update job has finished")
        if job.finished():
            if job.exception:
                syslog.syslog(syslog.LOG_ERR, "Get update job finished, error: %s"%str(job.exception))
                self.finished_get_updates(-1, "Error: %s"%str(job.exception))
            else:
                if job.result==0:    
                    syslog.syslog(syslog.LOG_INFO, "Get update job finished: no update available")
                    self.finished_get_updates(0, "No update available")
                elif job.result==1:
                    syslog.syslog(syslog.LOG_INFO, "Get update job finished: an update will be installed next reboot")
                    self.finished_get_updates(1, "An update will be installed next reboot")
                else:
                    syslog.syslog(syslog.LOG_WARNING, "Invalid job status '%s' for getting update"%job.result)
                    self.finished_get_updates(job.result, "Invalid job status '%s' for getting update"%job.result)
            self._get_updates_job=None
            self.status_changed()
            return False # don't keep the timer
        else:
            return True # keep timer

    @dbus.service.method("inseca.Manager.GetUpdates")
    def get_updates(self):
        """Search for any live Linux (build) repo, and returns True if a new
        update has been staged (to be installed at the next reboot)"""
        if self._get_updates_job:
            # already getting updates
            return
        if self._apply_update_job:
            # must wait for the staged update being applied first
            self.finished_get_updates(2, "A staged update is being applied")
            return

        job=jobs.LiveLinuxUpdatesGetJob(self._device_config_file, self._stage_dir)
        self._get_updates_job=job
        self.status_changed()
        job.start()
        GLib.timeout_add(1000, self._check_get_updated_job_finished, job)

    #
    # Applying staged update API
    #
    @dbus.service.signal("inseca.Manager.ApplyStagedUpdate", signature="is")
    def finished_apply_staged_update(self, status, message):
        """Signal that the job of getting updates is finished
        status:
        -1: an error occurred
         0 => no staged update exists
         1 => a staged update has been applied
        """
        syslog.syslog(syslog.LOG_INFO, "Apply staged finished: %s, %s"%(status, message))

    def _check_apply_staged_job_finished(self, job):
        if job.finished():
            if job.exception:
                syslog.syslog(syslog.LOG_ERR, "Apply staged job finished, error: %s"%str(job.exception))
                self.finished_apply_staged_update(-1, "Apply staged job finished, error: %s"%str(job.exception))
            else:
                if job.result==0:
                    syslog.syslog(syslog.LOG_INFO, "Apply staged job finished: no staged update available")
                    self.finished_apply_staged_update(0, "No staged update available")
                elif job.result==1:
                    syslog.syslog(syslog.LOG_INFO, "Apply staged job finished: an update has been applied, a reboot is needed")
                    self.finished_apply_staged_update(1, "An update has been applied, a reboot is needed")
                    # remove files in self._stage_dir
                    for fname in os.listdir(self._stage_dir):
                        path="%s/%s"%(self._stage_dir, fname)
                        try:
                            os.remove(path)
                        except Exception as e:
                            syslog.syslog(syslog.LOG_WARNING, "Could not remove '%s' file: %s"%(path, str(e)))        
                else:
                    syslog.syslog(syslog.LOG_ERR, "Invalid job status '%s' for applying staged update"%job.result)
                    self.finished_apply_staged_update(job.result, "Invalid job status '%s' for applying staged update"%job.result)
            self._apply_update_job=None
            self.status_changed()
            return False # don't keep the timer
        else:
            return True # keep timer

    #@dbus.service.method("inseca.Manager.ApplyStagedUpdate")
    # don't make this method callable using DBus because not needed and because
    # the API would require the user password and not the blob0, etc credentials
    # to avoid attack vectors supplying wrong credentials
    def apply_staged(self, blob0, int_password, data_password):
        """Apply a staged update if any"""
        if self._apply_update_job:
            return
        iso_file="%s/live-linux.iso"%self._stage_dir

        job=jobs.LiveLinuxUpdateApplyJob(iso_file, blob0, int_password, data_password)
        self._apply_update_job=job
        self.status_changed()
        job.start()
        GLib.timeout_add(1000, self._check_apply_staged_job_finished, job)

#
# Main
#
def get_updates_startup(remote):
    remote.get_updates()
    GLib.timeout_add(1000*60*60, get_updates_recurrent, remote) # run every hour
    return False # remove timer

def get_updates_recurrent(remote):
    remote.get_updates()
    return True # keep timer

try:
    syslog.syslog(syslog.LOG_INFO, "Creating Environment")

    # check if session is already opened
    if not live_env.startup_done:
        Misc.disable_networking()

        # configure accounts
        dev=Device.Device(live_env.live_devfile)
        upd=dev.get_unprotected_data()
        if "user-firstname" in upd:
            # change user's comment, for the UI
            util.change_user_comment(live_env.logged, upd["user-firstname"])

    # REM: if the graphical environment is not yet available, then the program will
    #      crash while creating the UI object, and will bre started by systemd
    ui=UI(live_env)
    syslog.syslog(syslog.LOG_INFO, "Created UI")

    if not live_env.startup_done:
        # load build-time configuration
        conf=None
        if os.path.exists("/etc/inseca-live-wks.json"):
            conf=json.load(open("/etc/inseca-live-wks.json", "r"))

        # get allowed virtual environments and test if executed in an allowed virtual environment
        venvs=[]
        if conf and "allowed-virtualized" in conf:
            data=conf["allowed-virtualized"]
            if data is not None:
                venvs=data.split(",")

        (status, out, err)=util.exec_sync(["systemd-detect-virt"])
        if status==0 and out not in venvs:
            ui.show_error("This system must not be used in a virtual environment")
            Gtk.main()
            exit(1)

        # disable some services if specificed
        dservs=[]
        servs=["update"] # services which can be disabled
        if conf and "disabled-net-services" in conf:
            data=conf["disabled-net-services"]
            if data is not None:
                dservs=data.split(",")
        if "all" in dservs:
            dservs=servs
        for serv in dservs:
            if serv:
                syslog.syslog(syslog.LOG_INFO, "Disabling INSECA '%s' service as specified in the build config"%serv)
                if serv=="update":
                    updates_enabled=False

    # remote command using DBus
    dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
    bus=dbus.SystemBus()
    name=dbus.service.BusName("inseca.Manager", bus)
    remote=Remote(bus, ui)
    ui.remote=remote # 'attach' the DBus object to the UI object

    if not live_env.startup_done:
        # define user's environment while not authenticated
        syslog.syslog(syslog.LOG_INFO, "Defining User env. while not authenticated")
        live_env.user_setting_set("org.gnome.desktop.background", "picture-uri", "")
        live_env.user_setting_set("org.gnome.desktop.background", "primary-color", "#ff5050") # red background
        live_env.user_setting_set("org.gnome.settings-daemon.plugins.power", "sleep-inactive-ac-type", "nothing")
        live_env.user_setting_set("org.gnome.settings-daemon.plugins.power", "sleep-inactive-battery-type", "nothing")
    elif updates_enabled:
        GLib.timeout_add(1000, get_updates_startup, remote) # try to get updates

    # Decide which UI page to show
    if ui.expired:
        ui.show_error("This device has expired (or invalid hardware clock)")
    elif live_env.startup_done:
        Misc.enable_networking()
        ui.show_page("final", can_close=True)
    else:
        ui.show_page("password")

    syslog.syslog(syslog.LOG_INFO, "Reached Gtk's main()")
    Gtk.main()

except Exception as e:
    syslog.syslog(syslog.LOG_ERR, "MAIN error: %s"%str(e))
    live_env.notify(str(e))
    ui.show_error(str(e))
    if Gtk.main_level()==0:
        Gtk.main()
